"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[606],{3905:function(e,t,n){n.d(t,{Zo:function(){return c},kt:function(){return b}});var r=n(7294);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function a(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,r,o=function(e,t){if(null==e)return{};var n,r,o={},i=Object.keys(e);for(r=0;r<i.length;r++)n=i[r],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(r=0;r<i.length;r++)n=i[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var s=r.createContext({}),u=function(e){var t=r.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):a(a({},t),e)),n},c=function(e){var t=u(e.components);return r.createElement(s.Provider,{value:t},e.children)},m={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},p=r.forwardRef((function(e,t){var n=e.components,o=e.mdxType,i=e.originalType,s=e.parentName,c=l(e,["components","mdxType","originalType","parentName"]),p=u(n),b=o,d=p["".concat(s,".").concat(b)]||p[b]||m[b]||i;return n?r.createElement(d,a(a({ref:t},c),{},{components:n})):r.createElement(d,a({ref:t},c))}));function b(e,t){var n=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var i=n.length,a=new Array(i);a[0]=p;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l.mdxType="string"==typeof e?e:o,a[1]=l;for(var u=2;u<i;u++)a[u]=n[u];return r.createElement.apply(null,a)}return r.createElement.apply(null,n)}p.displayName="MDXCreateElement"},4938:function(e,t,n){n.r(t),n.d(t,{assets:function(){return c},contentTitle:function(){return s},default:function(){return b},frontMatter:function(){return l},metadata:function(){return u},toc:function(){return m}});var r=n(3117),o=n(102),i=(n(7294),n(3905)),a=["components"],l={},s='Mover <img src="/img/catmover.png" className="image image_header" />',u={unversionedId:"mover",id:"mover",title:'Mover <img src="/img/catmover.png" className="image image_header" />',description:"About",source:"@site/docs/mover.md",sourceDirName:".",slug:"/mover",permalink:"/docs/mover",tags:[],version:"current",frontMatter:{}},c={},m=[{value:"About",id:"about",level:2},{value:"Setup",id:"setup",level:2},{value:"Properties",id:"properties",level:2},{value:"direction?: <em>MoverDirection</em>",id:"direction-moverdirection",level:3},{value:"memorizeCurrent?: <em>boolean</em>",id:"memorizecurrent-boolean",level:3},{value:"tabbable?: <em>boolean</em>",id:"tabbable-boolean",level:3},{value:"cyclic?: <em>boolean</em>",id:"cyclic-boolean",level:3},{value:"trackState?: <em>boolean</em>",id:"trackstate-boolean",level:3},{value:"visibilityAware?: <em>Visibility</em>",id:"visibilityaware-visibility",level:3},{value:"Examples",id:"examples",level:2}],p={toc:m};function b(e){var t=e.components,n=(0,o.Z)(e,a);return(0,i.kt)("wrapper",(0,r.Z)({},p,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"mover-"},"Mover ",(0,i.kt)("img",{src:"/img/catmover.png",className:"image image_header"})),(0,i.kt)("h2",{id:"about"},"About"),(0,i.kt)("p",null,"Mover allows to move focus within the container using arrow keys."),(0,i.kt)("p",null,"Mover plays well with ",(0,i.kt)("a",{parentName:"p",href:"/docs/groupper"},"Groupper"),"."),(0,i.kt)("p",null,"Consider the example:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-html"},'<div data-tabster=\'{"mover": {...}"\'>\n    <button>Button1</button>\n    <button>Button2</button>\n    <button>Button3</button>\n</div>\n')),(0,i.kt)("p",null,"Normally, it would take a Tab press to move between the buttons. With Mover, the focus will be moved when the arrow keys are pressed."),(0,i.kt)("h2",{id:"setup"},"Setup"),(0,i.kt)("p",null,"To get Mover working, we need to call ",(0,i.kt)("inlineCode",{parentName:"p"},"getMover()")," function:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},'import { createTabster, getMover } from "tabster";\n\nlet tabsterCore = createTabster(window);\n\ngetMover(tabsterCore);\n')),(0,i.kt)("h2",{id:"properties"},"Properties"),(0,i.kt)("p",null,"To tune the Mover's behaviour, several properties are available."),(0,i.kt)("h3",{id:"direction-moverdirection"},"direction?: ",(0,i.kt)("em",{parentName:"h3"},"MoverDirection")),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"Both | Vertical | Horizontal | Grid")),(0,i.kt)("p",null,"The default value is ",(0,i.kt)("inlineCode",{parentName:"p"},"Both")," meaning both Up/Down and Left/Right button\npresses will move focus to the previous/next focusable element inside the Mover."),(0,i.kt)("p",null,"With ",(0,i.kt)("inlineCode",{parentName:"p"},"Vertical")," only Up/Down buttons will move the focus."),(0,i.kt)("p",null,"With ",(0,i.kt)("inlineCode",{parentName:"p"},"Horizontal")," onlt Left/Right buttons will do."),(0,i.kt)("p",null,"With ",(0,i.kt)("inlineCode",{parentName:"p"},"Grid")," the focus will be moving to visually adjacent item when the arrow\nkeys are used."),(0,i.kt)("p",null,"Of course PageUp/PageDown, Home and End keys work for Mover too."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},'import { createTabster, getMover, getTabsterAttribute, Types } from "tabster";\n\nconst tabsterCore = createTabster(window);\ngetMover(tabsterCore);\n\n...\n\n<div {...getTabsterAttribute({ mover: { direction: Types.MoverDirections.Grid } })}>\n    ...\n</div>\n')),(0,i.kt)("h3",{id:"memorizecurrent-boolean"},"memorizeCurrent?: ",(0,i.kt)("em",{parentName:"h3"},"boolean")),(0,i.kt)("p",null,"When you Tab to Mover from outside, the focus will land on the first element of the Mover\n(or on the last one if you Tab backwards). With ",(0,i.kt)("inlineCode",{parentName:"p"},"memorizeCurrent")," set to true, Tabster\nwill remember last focusable element you have been interacting with in the Mover and once\nyou Tab to the Mover from outside, the focus will go not to the first/last focusable in\nthe Mover container, but to the last item you've interacted with previously (if available)."),(0,i.kt)("h3",{id:"tabbable-boolean"},"tabbable?: ",(0,i.kt)("em",{parentName:"h3"},"boolean")),(0,i.kt)("p",null,"By default when you press Tab inside the Mover, the focus will go outside of the Mover to\nthe next focusable element. That allows us to, for example, Tab past the infinite lists.\nThough sometime we might want both Tab and Arrow keys to work inside the Mover, so we can\nmake it tabbable."),(0,i.kt)("h3",{id:"cyclic-boolean"},"cyclic?: ",(0,i.kt)("em",{parentName:"h3"},"boolean")),(0,i.kt)("p",null,"When we press an arrow key to go to the next item while the last item is focused already,\nnothing happens by default. With ",(0,i.kt)("inlineCode",{parentName:"p"},"cyclic")," it will move the focus to the first item."),(0,i.kt)("h3",{id:"trackstate-boolean"},"trackState?: ",(0,i.kt)("em",{parentName:"h3"},"boolean")),(0,i.kt)("p",null,"Mover can track the state of visibility of its focusable elements. It triggers custom DOM\nevent ",(0,i.kt)("inlineCode",{parentName:"p"},"tabster:mover")," providing this state. The triggered event will also have ",(0,i.kt)("inlineCode",{parentName:"p"},"isCurrent"),"\nflag for the currently focused Mover item."),(0,i.kt)("p",null,"This should only be used when really needed, because it might have a performance impact\ncaused by observing the Mover's children visibility."),(0,i.kt)("h3",{id:"visibilityaware-visibility"},"visibilityAware?: ",(0,i.kt)("em",{parentName:"h3"},"Visibility")),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"Invisible | PartiallyVisible | Visible")),(0,i.kt)("p",null,"By default, when we Tab to a Mover from outside, the focus will go to the first rendered\nfocusable element inside the Mover. Which might make the list to scroll and might be\nvery inconvenient for the virtualized lists when the scrolling causes more items to load."),(0,i.kt)("p",null,"With ",(0,i.kt)("inlineCode",{parentName:"p"},"visibilityAware")," we can alter that behaviour to be able to Tab to the first visible\nelement instead of the first rendered one. Enables ",(0,i.kt)("inlineCode",{parentName:"p"},"trackState")," internally."),(0,i.kt)("h2",{id:"examples"},"Examples"),(0,i.kt)("p",null,(0,i.kt)("a",{parentName:"p",href:"https://tabster.io/storybook/?path=/story/mover"},"See a few Mover examples in the Storybook"),"."))}b.isMDXComponent=!0}}]);