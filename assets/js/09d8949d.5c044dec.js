"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[991],{3905:function(e,t,n){n.d(t,{Zo:function(){return c},kt:function(){return p}});var a=n(7294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function s(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function i(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var l=a.createContext({}),u=function(e){var t=a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):s(s({},t),e)),n},c=function(e){var t=u(e.components);return a.createElement(l.Provider,{value:t},e.children)},d={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},b=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,o=e.originalType,l=e.parentName,c=i(e,["components","mdxType","originalType","parentName"]),b=u(n),p=r,m=b["".concat(l,".").concat(p)]||b[p]||d[p]||o;return n?a.createElement(m,s(s({ref:t},c),{},{components:n})):a.createElement(m,s({ref:t},c))}));function p(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var o=n.length,s=new Array(o);s[0]=b;var i={};for(var l in t)hasOwnProperty.call(t,l)&&(i[l]=t[l]);i.originalType=e,i.mdxType="string"==typeof e?e:r,s[1]=i;for(var u=2;u<o;u++)s[u]=n[u];return a.createElement.apply(null,s)}return a.createElement.apply(null,n)}b.displayName="MDXCreateElement"},1756:function(e,t,n){n.r(t),n.d(t,{frontMatter:function(){return i},contentTitle:function(){return l},metadata:function(){return u},toc:function(){return c},default:function(){return b}});var a=n(7462),r=n(3366),o=(n(7294),n(3905)),s=["components"],i={},l="Core",u={unversionedId:"core",id:"core",title:"Core",description:"Setup",source:"@site/docs/core.md",sourceDirName:".",slug:"/core",permalink:"/docs/core",tags:[],version:"current",frontMatter:{}},c=[{value:"Setup",id:"setup",children:[],level:2},{value:"Types",id:"types",children:[],level:2},{value:"Methods",id:"methods",children:[{value:"createTabster()",id:"createtabster",children:[],level:3},{value:"disposeTabster()",id:"disposetabster",children:[],level:3},{value:"getTabsterAttribute()",id:"gettabsterattribute",children:[],level:3},{value:"setTabsterAttribute()",id:"settabsterattribute",children:[],level:3},{value:"getCurrentTabster()",id:"getcurrenttabster",children:[],level:3}],level:2},{value:"Core Instance",id:"core-instance",children:[{value:"keyboardNavigation",id:"keyboardnavigation",children:[],level:3},{value:"focusedElement",id:"focusedelement",children:[],level:3},{value:"focusable",id:"focusable",children:[],level:3}],level:2},{value:"Components",id:"components",children:[],level:2},{value:"Focusable Element Properties",id:"focusable-element-properties",children:[],level:2}],d={toc:c};function b(e){var t=e.components,n=(0,r.Z)(e,s);return(0,o.kt)("wrapper",(0,a.Z)({},d,n,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"core"},"Core"),(0,o.kt)("h2",{id:"setup"},"Setup"),(0,o.kt)("p",null,"In order to get Tabster working, we need to create an instance of Tabster core inside the\napplication code."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},'import { createTabster, disposeTabster } from "tabster";\n\n// During the page startup.\nlet tabsterCore = createTabster(window);\n\n// Don\'t forget to dispose on unload.\ndisposeTabster(tabsterCore);\n')),(0,o.kt)("p",null,"Once the Tabster core is created for a window, Tabster should become fully functional\nfor the window and the Tabster attributes could be used on the DOM nodes."),(0,o.kt)("p",null,"Although Tabster doesn't manage focus by default. To make it manage focus, we need\nto specify a container within which the focus is managed (usually, the root application\ncontainer)."),(0,o.kt)("p",null,"Tabster API is mostly declarative. Set ",(0,o.kt)("inlineCode",{parentName:"p"},"data-tabster")," attribute on a DOM node and it\nstarts behaving the required way."),(0,o.kt)("p",null,(0,o.kt)("inlineCode",{parentName:"p"},"data-tabster")," attribute is a serialized JSON with all Tabster components on the DOM\nnode, there is no need to build that value manually though. ",(0,o.kt)("inlineCode",{parentName:"p"},"getTabsterAttribute()"),"\nfunction should be used instead. Below is an example of a small React application using\nTabster."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-tsx"},'import * as React from "react";\nimport * as ReactDOM from "react-dom";\nimport {\n    createTabster,\n    getGroupper,\n    getMover,\n    getTabsterAttribute,\n    Types,\n} from "tabster";\n\nvar tabster = createTabster(window);\ngetMover(tabster);\ngetGroupper(tabster);\n\nReactDOM.render(\n    // Adding Tabster root, within that root Tabster manages focus.\n    <div {...getTabsterAttribute({ root: {} })}>\n        {/* Adding Mover, to be able to move between the list items using\n            Up/Down keys. */}\n        <ol\n            {...getTabsterAttribute({\n                mover: { direction: Types.MoverDirections.Vertical },\n            })}\n        >\n            {/* Adding Grouppers to the list items so that Mover treats\n            list items as singular entities (not looking at the inner\n            focusable buttons) and to trap the focus inside the\n            list item when we interact with it. */}\n            <li\n                tabIndex={0}\n                {...getTabsterAttribute({\n                    groupper: {\n                        tabbability:\n                            Types.GroupperTabbabilities.LimitedTrapFocus,\n                    },\n                })}\n            >\n                <button>Button1</button>\n                <button>Button2</button>\n            </li>\n            <li\n                tabIndex={0}\n                {...getTabsterAttribute({\n                    groupper: {\n                        tabbability:\n                            Types.GroupperTabbabilities.LimitedTrapFocus,\n                    },\n                })}\n            >\n                <button>Button3</button>\n                <button>Button4</button>\n            </li>\n            <li\n                tabIndex={0}\n                {...getTabsterAttribute({\n                    groupper: {\n                        tabbability:\n                            Types.GroupperTabbabilities.LimitedTrapFocus,\n                    },\n                })}\n            >\n                <button>Button5</button>\n                <button>Button6</button>\n            </li>\n        </ol>\n    </div>,\n    document.getElementById("root")\n);\n')),(0,o.kt)("p",null,"The generated HTML will look like this:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-html"},'<div data-tabster=\'{"root":{}}\'>\n    ...\n    <ol data-tabster=\'{"mover":{"direction":1}}\'>\n        <li tabindex="0" data-tabster=\'{"groupper":{"tabbability":2}}\'>\n            <button>Button1</button><button>Button2</button>\n        </li>\n        <li tabindex="0" data-tabster=\'{"groupper":{"tabbability":2}}\'>\n            <button>Button3</button><button>Button4</button>\n        </li>\n        <li tabindex="0" data-tabster=\'{"groupper":{"tabbability":2}}\'>\n            <button>Button5</button><button>Button6</button>\n        </li>\n    </ol>\n    ...\n</div>\n')),(0,o.kt)("p",null,"In that example we have a list of items, we can move between the items using Up/Down\narrow keys (",(0,o.kt)("a",{parentName:"p",href:"/docs/mover"},"Mover")," is used) and we can enter the item's inner buttons by\npressing Enter on a focused list item (and Esc to go back to the list item container,\n",(0,o.kt)("a",{parentName:"p",href:"/docs/groupper"},"Groupper")," is used)."),(0,o.kt)("h2",{id:"types"},"Types"),(0,o.kt)("p",null,"All Tabster-related TypeScript type definitions are stored in the Types namespace:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},'import { Types } from "tabster";\n')),(0,o.kt)("h2",{id:"methods"},"Methods"),(0,o.kt)("h3",{id:"createtabster"},"createTabster()"),(0,o.kt)("p",null,"Creates instance of Tabster core. This should be done during the application startup,\nit starts handling ",(0,o.kt)("inlineCode",{parentName:"p"},"data-tabster")," attribute of the DOM nodes."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},'import { createTabster } from "tabster";\n\nlet tabsterCore = createTabster(window);\n')),(0,o.kt)("h3",{id:"disposetabster"},"disposeTabster()"),(0,o.kt)("p",null,"It is important to not forget to dispose Tabster instance during the application\nunmount. Otherwise, it might lead to memory leaks in multi-window environments\n(like Electron applications)."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},'import { disposeTabster } from "tabster";\n\ndisposeTabster(tabsterCore);\n')),(0,o.kt)("h3",{id:"gettabsterattribute"},"getTabsterAttribute()"),(0,o.kt)("p",null,"Tabster attribute value should not be generated manually. ",(0,o.kt)("inlineCode",{parentName:"p"},"getTabsterAttribute()"),"\nfunction provides a properly typed helper for building the value."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},"// Returns object like { 'data-tabster': '{...}' }.\ngetTabsterAttribute(props: Types.TabsterAttributeProps): Types.TabsterDOMAttribute;\n// Only returns the attribute value as string.\ngetTabsterAttribute(props: Types.TabsterAttributeProps, plain: true): string;\n")),(0,o.kt)("h3",{id:"settabsterattribute"},"setTabsterAttribute()"),(0,o.kt)("p",null,"Another helper function which helps to set or update Tabster attribute\non an HTMLElement instance programmaticaly."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},"setTabsterAttribute(\n    element: HTMLElement,\n    newProps: Types.TabsterAttributeProps,\n    update?: boolean // When true, newProps will be added to the existing\n                    // Tabster props on that element, otherwise, the existing\n                    // props will be replaced by newProps.\n): void;\n")),(0,o.kt)("h3",{id:"getcurrenttabster"},"getCurrentTabster()"),(0,o.kt)("p",null,"If a Tabster core instance has already been created for the window, returns that instance."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},'import { getCurrentTabster } from "tabster";\n\nlet tabsterCore = getCurrentTabster(window);\n\nif (tabsterCore) {\n    ...\n}\n')),(0,o.kt)("h2",{id:"core-instance"},"Core Instance"),(0,o.kt)("p",null,"Tabster core instance provides a few APIs."),(0,o.kt)("h3",{id:"keyboardnavigation"},"keyboardNavigation"),(0,o.kt)("p",null,"Keyboard navigation state is used to determine if the user is using keyboard\nto navigate the application. You can subscribe to the keyboard navigation state\nchanges or determine the current state. Keyboard navigation state implementation\ndetects if the focus is moved not using the mouse or programmatically (i.e. Tab\nis pressed or screen reader moves the focus)."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},"interface KeyboardNavigationState {\n    subscribe(callback: (value: boolean) => void): void;\n    unsubscribe(callback: (value: boolean) => void): void;\n    isNavigatingWithKeyboard(): boolean;\n}\n")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},'import { createTabster } from "tabster";\n\nlet tabsterCore = createTabster(window);\n\nconsole.log(\n    "Current keyboard navigation state:",\n    tabsterCore.keyboardNavigation.isNavigatingWithKeyboard()\n);\n\ntabster.keyboardNavigation.subscribe((isNavigatingWithKeyboard: boolean) => {\n    console.log("Keyboard navigation state changed:", isNavigatingWithKeyboard);\n});\n')),(0,o.kt)("h3",{id:"focusedelement"},"focusedElement"),(0,o.kt)("p",null,"Focused element state holds currently focused element and provides focusing\nhelper functions."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},"interface FocusedElementState {\n    subscribe(\n        callback: (HTMLElement | undefined, details: FocusedElementDetails): void\n    ): void;\n    unsubscribe(\n        callback: (HTMLElement | undefined, details: FocusedElementDetails): void\n    ): void;\n    // Returns currently focused element.\n    getFocusedElement(): HTMLElement | undefined;\n    // Returns last focused element (even if the currently focused one is\n    // undefined).\n    getLastFocusedElement(): HTMLElement | undefined;\n    // Focuses the element. By default the focus function provides the\n    // accessibility check (to not focus something which is not accessible).\n    // Also, whenever you focus something programmatically, FocusedElementDetails\n    // in the focused element state callback receives a flag that the element\n    // is focused programmatically, here we can override that flag.\n    // Returns true when the element is successfully focused.\n    focus(\n        element: HTMLElement,\n        noFocusedProgrammaticallyFlag?: boolean,\n        noAccessibleCheck?: boolean\n    ): boolean;\n    // We can mark some DOM node default focusable using Tabster attribute.\n    // This function will find such default focusable in the container (if any)\n    // and focus it. Returns true if successful.\n    focusDefault(container: HTMLElement): boolean;\n    // focusFirst/focusLast find first/last focusable element within the\n    // container and focus it, returning true if successful.\n    focusFirst(props: FindFirstProps): boolean;\n    focusLast(props: FindFirstProps): boolean;\n    // Gets a container in a state when first Tab press will move the focus\n    // to the first focusable element in the container.\n    resetFocus(container: HTMLElement): boolean;\n}\n")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},'import { createTabster } from "tabster";\n\nlet tabsterCore = createTabster(window);\n\nlet element = tabsterCore.focusedElement.getLastFocusedElement();\n')),(0,o.kt)("h3",{id:"focusable"},"focusable"),(0,o.kt)("p",null,"Focusable API provides a set of methods to check and find focusable elements."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},"export interface FocusableAPI {\n    // Returns\n    getProps(element: HTMLElement): FocusableProps;\n    // Checks if the element is focusable.\n    isFocusable(\n        element: HTMLElement,\n        includeProgrammaticallyFocusable?: boolean,\n        noVisibleCheck?: boolean,\n        noAccessibleCheck?: boolean\n    ): boolean;\n    // Checks if the element is visible.\n    isVisible(element: HTMLElement): boolean;\n    // Checks if the element is accessible (using screen readers).\n    isAccessible(element: HTMLElement): boolean;\n    // Methods to find focusables on the page.\n    findFirst(options: FindFirstProps): HTMLElement | null | undefined;\n    findLast(options: FindFirstProps): HTMLElement | null | undefined;\n    findNext(options: FindNextProps): HTMLElement | null | undefined;\n    findPrev(options: FindNextProps): HTMLElement | null | undefined;\n    findDefault(options: FindDefaultProps): HTMLElement | null;\n    findAll(options: FindAllProps): HTMLElement[];\n    findElement(options: FindFocusableProps): HTMLElement | null | undefined;\n}\n")),(0,o.kt)("h2",{id:"components"},"Components"),(0,o.kt)("p",null,"Core instance runs the main Tabster engine, but what really makes it useful\nare the rest of Tabster's components. We have ",(0,o.kt)("a",{parentName:"p",href:"/docs/mover"},"Mover"),", ",(0,o.kt)("a",{parentName:"p",href:"/docs/groupper"},"Groupper"),",\n",(0,o.kt)("a",{parentName:"p",href:"/docs/deloser"},"Deloser"),", ",(0,o.kt)("a",{parentName:"p",href:"/docs/modalizer"},"Modalizer"),", ",(0,o.kt)("a",{parentName:"p",href:"/docs/observed"},"Observed")," and\n",(0,o.kt)("a",{parentName:"p",href:"/docs/outline"},"Outline"),"."),(0,o.kt)("p",null,"To use these components, an additional function needs to be called right after\nTabster core creation in order to enable them. This is because Tabster is treeshakeable\nand only the components which are actually used should reach the final application\nbundle."),(0,o.kt)("h2",{id:"focusable-element-properties"},"Focusable Element Properties"),(0,o.kt)("p",null,"We can use Tabster attribute to set some additional properties on the focusable element."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},"interface FocusableProps {\n    // Mark element as default focusable which is used in\n    // tabsterCore.focusedElement.focusDefault() and in Deloser.\n    isDefault?: boolean;\n    // Sometimes we might have some technical element on the page and we want\n    // it to be ignored.\n    isIgnored?: boolean;\n    // Do not determine element's focusability based on aria-disabled. Sometimes\n    // elements with aria-disabled must still be focusable.\n    ignoreAriaDisabled?: boolean;\n}\n")),(0,o.kt)("p",null,"Example:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-html"},'<button data-tabster=\'{"focusable": {"isDefault": true}}\'>Press Me</button>\n')))}b.isMDXComponent=!0}}]);